{"ast":null,"code":"import { Color, DefaultLoadingManager, FileLoader, FrontSide, Loader, LoaderUtils, MeshPhongMaterial, RepeatWrapping, TextureLoader, Vector2 } from 'three';\n/**\r\n * Loads a Wavefront .mtl file specifying materials\r\n */\n\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  /**\r\n   * Loads and parses a MTL asset from a URL.\r\n   *\r\n   * @param {String} url - URL to the MTL file.\r\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\r\n   * @param {Function} [onProgress] - Callback for download progress.\r\n   * @param {Function} [onError] - Callback for download errors.\r\n   *\r\n   * @see setPath setResourcePath\r\n   *\r\n   * @note In order for relative texture references to resolve correctly\r\n   * you must call setResourcePath() explicitly prior to load.\r\n   */\n\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  setMaterialOptions(value) {\n    this.materialOptions = value;\n    return this;\n  }\n  /**\r\n   * Parses a MTL file.\r\n   *\r\n   * @param {String} text - Content of MTL file\r\n   * @return {MaterialCreator}\r\n   *\r\n   * @see setPath setResourcePath\r\n   *\r\n   * @note In order for relative texture references to resolve correctly\r\n   * you must call setResourcePath() explicitly prior to parse.\r\n   */\n\n\n  parse(text, path) {\n    const lines = text.split('\\n');\n    let info = {};\n    const delimiter_pattern = /\\s+/;\n    const materialsInfo = {};\n\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      line = line.trim();\n\n      if (line.length === 0 || line.charAt(0) === '#') {\n        // Blank line or comment ignore\n        continue;\n      }\n\n      const pos = line.indexOf(' ');\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      let value = pos >= 0 ? line.substring(pos + 1) : '';\n      value = value.trim();\n\n      if (key === 'newmtl') {\n        // New material\n        info = {\n          name: value\n        };\n        materialsInfo[value] = info;\n      } else {\n        if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {\n          const ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n\n}\n/**\r\n * Create a new MTLLoader.MaterialCreator\r\n * @param baseUrl - Url relative to which textures are loaded\r\n * @param options - Set of options on how to construct the materials\r\n *                  side: Which side to apply the material\r\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\r\n *                  wrap: What type of wrapping to apply for textures\r\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\r\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\r\n *                                Default: false, assumed to be already normalized\r\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\r\n *                                  Default: false\r\n * @constructor\r\n */\n\n\nclass MaterialCreator {\n  constructor(baseUrl = '', options = {}) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = 'anonymous';\n    this.side = this.options.side !== undefined ? this.options.side : FrontSide;\n    this.wrap = this.options.wrap !== undefined ? this.options.wrap : RepeatWrapping;\n  }\n\n  setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  }\n\n  setManager(value) {\n    this.manager = value;\n  }\n\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  }\n\n  convert(materialsInfo) {\n    if (!this.options) return materialsInfo;\n    const converted = {};\n\n    for (const mn in materialsInfo) {\n      // Convert materials info into normalized form based on options\n      const mat = materialsInfo[mn];\n      const covmat = {};\n      converted[mn] = covmat;\n\n      for (const prop in mat) {\n        let save = true;\n        let value = mat[prop];\n        const lprop = prop.toLowerCase();\n\n        switch (lprop) {\n          case 'kd':\n          case 'ka':\n          case 'ks':\n            // Diffuse color (color under white light) using RGB values\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                // ignore\n                save = false;\n              }\n            }\n\n            break;\n\n          default:\n            break;\n        }\n\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n\n    return converted;\n  }\n\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  }\n\n  getIndex(materialName) {\n    return this.nameLookup[materialName];\n  }\n\n  getAsArray() {\n    let index = 0;\n\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n\n    return this.materialsArray;\n  }\n\n  create(materialName) {\n    if (this.materials[materialName] === undefined) {\n      this.createMaterial_(materialName);\n    }\n\n    return this.materials[materialName];\n  }\n\n  createMaterial_(materialName) {\n    // Create material\n    const scope = this;\n    const mat = this.materialsInfo[materialName];\n    const params = {\n      name: materialName,\n      side: this.side\n    };\n\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== 'string' || url === '') return ''; // Absolute URL\n\n      if (/^https?:\\/\\//i.test(url)) return url;\n      return baseUrl + url;\n    }\n\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return; // Keep the first encountered texture\n\n      const texParams = scope.getTextureParams(value, params);\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      params[mapType] = map;\n    }\n\n    for (const prop in mat) {\n      const value = mat[prop];\n      let n;\n      if (value === '') continue;\n\n      switch (prop.toLowerCase()) {\n        // Ns is material specular exponent\n        case 'kd':\n          // Diffuse color (color under white light) using RGB values\n          params.color = new Color().fromArray(value);\n          break;\n\n        case 'ks':\n          // Specular color (color when light is reflected from shiny surface) using RGB values\n          params.specular = new Color().fromArray(value);\n          break;\n\n        case 'ke':\n          // Emissive using RGB values\n          params.emissive = new Color().fromArray(value);\n          break;\n\n        case 'map_kd':\n          // Diffuse texture map\n          setMapForType('map', value);\n          break;\n\n        case 'map_ks':\n          // Specular map\n          setMapForType('specularMap', value);\n          break;\n\n        case 'map_ke':\n          // Emissive map\n          setMapForType('emissiveMap', value);\n          break;\n\n        case 'norm':\n          setMapForType('normalMap', value);\n          break;\n\n        case 'map_bump':\n        case 'bump':\n          // Bump texture map\n          setMapForType('bumpMap', value);\n          break;\n\n        case 'map_d':\n          // Alpha map\n          setMapForType('alphaMap', value);\n          params.transparent = true;\n          break;\n\n        case 'ns':\n          // The specular exponent (defines the focus of the specular highlight)\n          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n          params.shininess = parseFloat(value);\n          break;\n\n        case 'd':\n          n = parseFloat(value);\n\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n\n          break;\n\n        case 'tr':\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty) n = 1 - n;\n\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  }\n\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    const items = value.split(/\\s+/);\n    let pos;\n    pos = items.indexOf('-bm');\n\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n\n    pos = items.indexOf('-s');\n\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n\n    pos = items.indexOf('-o');\n\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n\n    texParams.url = items.join(' ').trim();\n    return texParams;\n  }\n\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== undefined ? this.manager : DefaultLoadingManager;\n    let loader = manager.getHandler(url);\n\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n    const texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== undefined) texture.mapping = mapping;\n    return texture;\n  }\n\n}\n\nexport { MTLLoader };","map":{"version":3,"sources":["C:/Users/HP/Desktop/supaps-bs/node_modules/three/examples/jsm/loaders/MTLLoader.js"],"names":["Color","DefaultLoadingManager","FileLoader","FrontSide","Loader","LoaderUtils","MeshPhongMaterial","RepeatWrapping","TextureLoader","Vector2","MTLLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterialOptions","value","materialOptions","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","name","ss","parseFloat","materialCreator","MaterialCreator","resourcePath","setCrossOrigin","crossOrigin","setManager","setMaterials","baseUrl","options","materials","materialsArray","nameLookup","side","undefined","wrap","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","preload","create","getIndex","materialName","getAsArray","index","createMaterial_","params","resolveURL","test","setMapForType","mapType","texParams","getTextureParams","map","loadTexture","repeat","copy","scale","offset","wrapS","wrapT","n","color","fromArray","specular","emissive","transparent","shininess","opacity","invertTrProperty","matParams","items","bumpScale","splice","set","join","mapping","getHandler","texture"],"mappings":"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","sourcesContent":["import {\r\n\tColor,\r\n\tDefaultLoadingManager,\r\n\tFileLoader,\r\n\tFrontSide,\r\n\tLoader,\r\n\tLoaderUtils,\r\n\tMeshPhongMaterial,\r\n\tRepeatWrapping,\r\n\tTextureLoader,\r\n\tVector2\r\n} from 'three';\r\n\r\n/**\r\n * Loads a Wavefront .mtl file specifying materials\r\n */\r\n\r\nclass MTLLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Loads and parses a MTL asset from a URL.\r\n\t *\r\n\t * @param {String} url - URL to the MTL file.\r\n\t * @param {Function} [onLoad] - Callback invoked with the loaded object.\r\n\t * @param {Function} [onProgress] - Callback for download progress.\r\n\t * @param {Function} [onError] - Callback for download errors.\r\n\t *\r\n\t * @see setPath setResourcePath\r\n\t *\r\n\t * @note In order for relative texture references to resolve correctly\r\n\t * you must call setResourcePath() explicitly prior to load.\r\n\t */\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( text, path ) );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tsetMaterialOptions( value ) {\r\n\r\n\t\tthis.materialOptions = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Parses a MTL file.\r\n\t *\r\n\t * @param {String} text - Content of MTL file\r\n\t * @return {MaterialCreator}\r\n\t *\r\n\t * @see setPath setResourcePath\r\n\t *\r\n\t * @note In order for relative texture references to resolve correctly\r\n\t * you must call setResourcePath() explicitly prior to parse.\r\n\t */\r\n\tparse( text, path ) {\r\n\r\n\t\tconst lines = text.split( '\\n' );\r\n\t\tlet info = {};\r\n\t\tconst delimiter_pattern = /\\s+/;\r\n\t\tconst materialsInfo = {};\r\n\r\n\t\tfor ( let i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\tlet line = lines[ i ];\r\n\t\t\tline = line.trim();\r\n\r\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\r\n\r\n\t\t\t\t// Blank line or comment ignore\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pos = line.indexOf( ' ' );\r\n\r\n\t\t\tlet key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\r\n\t\t\tkey = key.toLowerCase();\r\n\r\n\t\t\tlet value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\r\n\t\t\tvalue = value.trim();\r\n\r\n\t\t\tif ( key === 'newmtl' ) {\r\n\r\n\t\t\t\t// New material\r\n\r\n\t\t\t\tinfo = { name: value };\r\n\t\t\t\tmaterialsInfo[ value ] = info;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {\r\n\r\n\t\t\t\t\tconst ss = value.split( delimiter_pattern, 3 );\r\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tinfo[ key ] = value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst materialCreator = new MaterialCreator( this.resourcePath || path, this.materialOptions );\r\n\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\r\n\t\tmaterialCreator.setManager( this.manager );\r\n\t\tmaterialCreator.setMaterials( materialsInfo );\r\n\t\treturn materialCreator;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Create a new MTLLoader.MaterialCreator\r\n * @param baseUrl - Url relative to which textures are loaded\r\n * @param options - Set of options on how to construct the materials\r\n *                  side: Which side to apply the material\r\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\r\n *                  wrap: What type of wrapping to apply for textures\r\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\r\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\r\n *                                Default: false, assumed to be already normalized\r\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\r\n *                                  Default: false\r\n * @constructor\r\n */\r\n\r\nclass MaterialCreator {\r\n\r\n\tconstructor( baseUrl = '', options = {} ) {\r\n\r\n\t\tthis.baseUrl = baseUrl;\r\n\t\tthis.options = options;\r\n\t\tthis.materialsInfo = {};\r\n\t\tthis.materials = {};\r\n\t\tthis.materialsArray = [];\r\n\t\tthis.nameLookup = {};\r\n\r\n\t\tthis.crossOrigin = 'anonymous';\r\n\r\n\t\tthis.side = ( this.options.side !== undefined ) ? this.options.side : FrontSide;\r\n\t\tthis.wrap = ( this.options.wrap !== undefined ) ? this.options.wrap : RepeatWrapping;\r\n\r\n\t}\r\n\r\n\tsetCrossOrigin( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetManager( value ) {\r\n\r\n\t\tthis.manager = value;\r\n\r\n\t}\r\n\r\n\tsetMaterials( materialsInfo ) {\r\n\r\n\t\tthis.materialsInfo = this.convert( materialsInfo );\r\n\t\tthis.materials = {};\r\n\t\tthis.materialsArray = [];\r\n\t\tthis.nameLookup = {};\r\n\r\n\t}\r\n\r\n\tconvert( materialsInfo ) {\r\n\r\n\t\tif ( ! this.options ) return materialsInfo;\r\n\r\n\t\tconst converted = {};\r\n\r\n\t\tfor ( const mn in materialsInfo ) {\r\n\r\n\t\t\t// Convert materials info into normalized form based on options\r\n\r\n\t\t\tconst mat = materialsInfo[ mn ];\r\n\r\n\t\t\tconst covmat = {};\r\n\r\n\t\t\tconverted[ mn ] = covmat;\r\n\r\n\t\t\tfor ( const prop in mat ) {\r\n\r\n\t\t\t\tlet save = true;\r\n\t\t\t\tlet value = mat[ prop ];\r\n\t\t\t\tconst lprop = prop.toLowerCase();\r\n\r\n\t\t\t\tswitch ( lprop ) {\r\n\r\n\t\t\t\t\tcase 'kd':\r\n\t\t\t\t\tcase 'ka':\r\n\t\t\t\t\tcase 'ks':\r\n\r\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\r\n\r\n\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\r\n\r\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\r\n\r\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t// ignore\r\n\r\n\t\t\t\t\t\t\t\tsave = false;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( save ) {\r\n\r\n\t\t\t\t\tcovmat[ lprop ] = value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn converted;\r\n\r\n\t}\r\n\r\n\tpreload() {\r\n\r\n\t\tfor ( const mn in this.materialsInfo ) {\r\n\r\n\t\t\tthis.create( mn );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetIndex( materialName ) {\r\n\r\n\t\treturn this.nameLookup[ materialName ];\r\n\r\n\t}\r\n\r\n\tgetAsArray() {\r\n\r\n\t\tlet index = 0;\r\n\r\n\t\tfor ( const mn in this.materialsInfo ) {\r\n\r\n\t\t\tthis.materialsArray[ index ] = this.create( mn );\r\n\t\t\tthis.nameLookup[ mn ] = index;\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.materialsArray;\r\n\r\n\t}\r\n\r\n\tcreate( materialName ) {\r\n\r\n\t\tif ( this.materials[ materialName ] === undefined ) {\r\n\r\n\t\t\tthis.createMaterial_( materialName );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.materials[ materialName ];\r\n\r\n\t}\r\n\r\n\tcreateMaterial_( materialName ) {\r\n\r\n\t\t// Create material\r\n\r\n\t\tconst scope = this;\r\n\t\tconst mat = this.materialsInfo[ materialName ];\r\n\t\tconst params = {\r\n\r\n\t\t\tname: materialName,\r\n\t\t\tside: this.side\r\n\r\n\t\t};\r\n\r\n\t\tfunction resolveURL( baseUrl, url ) {\r\n\r\n\t\t\tif ( typeof url !== 'string' || url === '' )\r\n\t\t\t\treturn '';\r\n\r\n\t\t\t// Absolute URL\r\n\t\t\tif ( /^https?:\\/\\//i.test( url ) ) return url;\r\n\r\n\t\t\treturn baseUrl + url;\r\n\r\n\t\t}\r\n\r\n\t\tfunction setMapForType( mapType, value ) {\r\n\r\n\t\t\tif ( params[ mapType ] ) return; // Keep the first encountered texture\r\n\r\n\t\t\tconst texParams = scope.getTextureParams( value, params );\r\n\t\t\tconst map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\r\n\r\n\t\t\tmap.repeat.copy( texParams.scale );\r\n\t\t\tmap.offset.copy( texParams.offset );\r\n\r\n\t\t\tmap.wrapS = scope.wrap;\r\n\t\t\tmap.wrapT = scope.wrap;\r\n\r\n\t\t\tparams[ mapType ] = map;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( const prop in mat ) {\r\n\r\n\t\t\tconst value = mat[ prop ];\r\n\t\t\tlet n;\r\n\r\n\t\t\tif ( value === '' ) continue;\r\n\r\n\t\t\tswitch ( prop.toLowerCase() ) {\r\n\r\n\t\t\t\t// Ns is material specular exponent\r\n\r\n\t\t\t\tcase 'kd':\r\n\r\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\r\n\r\n\t\t\t\t\tparams.color = new Color().fromArray( value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ks':\r\n\r\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\r\n\t\t\t\t\tparams.specular = new Color().fromArray( value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ke':\r\n\r\n\t\t\t\t\t// Emissive using RGB values\r\n\t\t\t\t\tparams.emissive = new Color().fromArray( value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_kd':\r\n\r\n\t\t\t\t\t// Diffuse texture map\r\n\r\n\t\t\t\t\tsetMapForType( 'map', value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_ks':\r\n\r\n\t\t\t\t\t// Specular map\r\n\r\n\t\t\t\t\tsetMapForType( 'specularMap', value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_ke':\r\n\r\n\t\t\t\t\t// Emissive map\r\n\r\n\t\t\t\t\tsetMapForType( 'emissiveMap', value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'norm':\r\n\r\n\t\t\t\t\tsetMapForType( 'normalMap', value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_bump':\r\n\t\t\t\tcase 'bump':\r\n\r\n\t\t\t\t\t// Bump texture map\r\n\r\n\t\t\t\t\tsetMapForType( 'bumpMap', value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_d':\r\n\r\n\t\t\t\t\t// Alpha map\r\n\r\n\t\t\t\t\tsetMapForType( 'alphaMap', value );\r\n\t\t\t\t\tparams.transparent = true;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ns':\r\n\r\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\r\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\r\n\r\n\t\t\t\t\tparams.shininess = parseFloat( value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'd':\r\n\t\t\t\t\tn = parseFloat( value );\r\n\r\n\t\t\t\t\tif ( n < 1 ) {\r\n\r\n\t\t\t\t\t\tparams.opacity = n;\r\n\t\t\t\t\t\tparams.transparent = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'tr':\r\n\t\t\t\t\tn = parseFloat( value );\r\n\r\n\t\t\t\t\tif ( this.options && this.options.invertTrProperty ) n = 1 - n;\r\n\r\n\t\t\t\t\tif ( n > 0 ) {\r\n\r\n\t\t\t\t\t\tparams.opacity = 1 - n;\r\n\t\t\t\t\t\tparams.transparent = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.materials[ materialName ] = new MeshPhongMaterial( params );\r\n\t\treturn this.materials[ materialName ];\r\n\r\n\t}\r\n\r\n\tgetTextureParams( value, matParams ) {\r\n\r\n\t\tconst texParams = {\r\n\r\n\t\t\tscale: new Vector2( 1, 1 ),\r\n\t\t\toffset: new Vector2( 0, 0 )\r\n\r\n\t\t };\r\n\r\n\t\tconst items = value.split( /\\s+/ );\r\n\t\tlet pos;\r\n\r\n\t\tpos = items.indexOf( '-bm' );\r\n\r\n\t\tif ( pos >= 0 ) {\r\n\r\n\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\r\n\t\t\titems.splice( pos, 2 );\r\n\r\n\t\t}\r\n\r\n\t\tpos = items.indexOf( '-s' );\r\n\r\n\t\tif ( pos >= 0 ) {\r\n\r\n\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\r\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\r\n\r\n\t\t}\r\n\r\n\t\tpos = items.indexOf( '-o' );\r\n\r\n\t\tif ( pos >= 0 ) {\r\n\r\n\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\r\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\r\n\r\n\t\t}\r\n\r\n\t\ttexParams.url = items.join( ' ' ).trim();\r\n\t\treturn texParams;\r\n\r\n\t}\r\n\r\n\tloadTexture( url, mapping, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst manager = ( this.manager !== undefined ) ? this.manager : DefaultLoadingManager;\r\n\t\tlet loader = manager.getHandler( url );\r\n\r\n\t\tif ( loader === null ) {\r\n\r\n\t\t\tloader = new TextureLoader( manager );\r\n\r\n\t\t}\r\n\r\n\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tconst texture = loader.load( url, onLoad, onProgress, onError );\r\n\r\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { MTLLoader };\r\n"]},"metadata":{},"sourceType":"module"}